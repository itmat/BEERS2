import argparse
import sys
import os
import collections
import bisect
from timeit import default_timer as timer
from beers.utilities.expression_utils import ExpressionUtils

class UpdateAnnotationForGenomeStep:
    """Updates a gene annotation's coordinates to account for insertions &
    deletions (indels) introduced by GenomeFilesPreparation when it creates
    variant genomes. Note, this is designed to update annotation for a single
    variant genome at a time.

    Parameters
    ----------
    genome_indel_filename : string
        Path to file containing list of indel locations generated by the
        GenomeFilesPreparation. This file has no header and contains three,
        tab-delimited colums (example):
            1:134937	D	2
            1:138813	I	1
        First column = Chromosome and coordinate of indel in the original
                       reference genome. Note, coordinate is zero-based.
        Second column = "D" if variant is a deletion, "I" if variant is an
                        insertion.
        Third column = Length in bases of indel.
    input_annot_filename : string
        Path to file containing gene/transcript annotations using coordinates
        to the original reference genome. This file should have 11, tab-delimited
        columns and includes a header (example):
            chrom  strand  txStart  txEnd exonCount  exonStarts         exonEnds           transcriptID     geneID           geneSymbol  biotype
            1      +       11869    14409 3          11869,12613,13221  12227,12721,14409  ENST00000456328  ENSG00000223972  DDX11L1     pseudogene
        An annotation file with this format can be generated from a GTF file
        using the convert_gtf_to_annot_file_format() function in the Utils
        package. A template for this annotation format is available in the
        class variable Utils.annot_output_format.
    updated_annot_filename : string
        Path to the output file containing gene/transcript annotations with
        coordinates updated to match the variant genome.
    log_filename : string
        Path to the log file.
    """

    name = "Update Annotation For Genome Step"

    def __init__(self, log_directory_path, data_directory_path, parameters=dict()):
        """Short summary.

        Parameters
        ----------
        data_directory_path: string
            Full path to data directory
        log_directory_path : string
            Full path to log directory.
        """
        self.data_directory_path = data_directory_path
        self.log_directory_path = log_directory_path

    def validate(self):
        return True

    def execute(self, sample, genome_indel_suffix, input_annot_file_path, chr_ploidy_file_path):
        """Main work-horse function that generates the updated annotation.

         Parameters
        ----------
        genome_indel_suffix : string
             Suffix to apply to obtain proper genome indel file..
        input_annot_filename : string
            Full path to annotation file with coordinates for reference genome.
        """

        # Compute which chromosomes we need to have in this annotation
        # If we are in annotation_2, we only want ones with ploidy 2 in this gender
        gender_index = 1 if sample.gender == "female" else 0
        self.chr_ploidy = self._get_chr_ploidy_from_file(chr_ploidy_file_path)
        desired_chromosomes = [chromosome for chromosome, ploidies in self.chr_ploidy.items()
                                if  ploidies[gender_index] >= genome_indel_suffix]

        self.genome_indel_file_path = os.path.join(self.data_directory_path, f"sample{sample.sample_id}",
                                                   f"custom_genome_indels_{genome_indel_suffix}.txt")
        self.input_annot_file_path = input_annot_file_path
        self.updated_annot_file_path = os.path.join(self.data_directory_path, f"sample{sample.sample_id}",
                                                    f"updated_annotation_{genome_indel_suffix}.txt")
        self.log_file_path = os.path.join(self.log_directory_path, f'sample{sample.sample_id}', __class__.__name__ + f"{genome_indel_suffix}.log")


        #Load indel offsets from the indel file
        indel_offsets = UpdateAnnotationForGenomeStep._get_offsets_from_variant_file(self.genome_indel_file_path)

        with open(self.input_annot_file_path, 'r') as input_annot_file, \
                open(self.updated_annot_file_path, 'w') as updated_annot_file, \
                open(self.log_file_path, 'w') as log_file:

            #Print header for annotation file
            updated_annot_file.write("#" + ExpressionUtils.annot_output_format.replace('{', '').replace('}', ''))

            current_chrom = ""

            for annot_feature in input_annot_file:

                annot_feature = annot_feature.rstrip('\n')
                line_data = annot_feature.split('\t')

                if current_chrom != line_data[0]:

                    #Skip header lines (nest in here so it's only checked when
                    #chromosomes change).
                    if annot_feature[0] == '#':
                        continue

                    current_chrom = line_data[0]
                    log_file.write(f"Processing indels and annotated features from chromosome {current_chrom}.\n")

                    if current_chrom in indel_offsets:
                        """
                        Since code below will be performing many lookups and index-
                        based references to the values and keys in current_chrom_variants,
                        it will likely be more efficient to create a list of values
                        and a list of keys from current_chrom_variants once, rather
                        than re-creating them each time the code needs to access a
                        key or value by ordered index.
                        """
                        current_chrom_variant_coords = list(indel_offsets[current_chrom].keys())
                        current_chrom_variant_offsets = list(indel_offsets[current_chrom].values())
                    else:
                        #New chromosome contains no variants
                        log_file.write(f"----No indels from chromosome {current_chrom}.\n")
                        current_chrom_variant_coords = ()
                        current_chrom_variant_coords = ()

                if current_chrom not in desired_chromosomes:
                    continue

                #Current chromosome contains variants
                if current_chrom_variant_coords:

                    tx_start = int(line_data[2])
                    tx_end = int(line_data[3])
                    #exon_count = int(line_data[4])
                    exon_starts = [int(coord) for coord in line_data[5].split(',')]
                    exon_ends = [int(coord) for coord in line_data[6].split(',')]

                    #bisect_right() finds the index at which to insert the given
                    #coordinate in sorted order. Since I'm looking for the
                    #closest coordinate <= the given coordinate, subtract 1 from
                    #the result of bisect_right() to get the correct index.
                    tx_start_offset_index = bisect.bisect_right(current_chrom_variant_coords, tx_start) - 1
                    tx_end_offset_index = bisect.bisect_right(current_chrom_variant_coords, tx_end) - 1

                    #No indels before start of current feature.
                    if tx_start_offset_index == -1:

                        updated_tx_start = tx_start

                        #No indels before end of current feature
                        if tx_end_offset_index == -1:
                            updated_tx_end = tx_end
                            updated_exon_starts = exon_starts
                            updated_exon_ends = exon_ends
                        #First indels occur before end of current feature
                        else:
                            updated_tx_end = tx_end + current_chrom_variant_offsets[tx_end_offset_index]

                            updated_exon_starts = []
                            updated_exon_ends = []
                            for coord in exon_starts:
                                ex_coord_offset_index = bisect.bisect_right(current_chrom_variant_coords, coord) - 1
                                updated_exon_coord = coord
                                if ex_coord_offset_index >= 0:
                                    updated_exon_coord += current_chrom_variant_offsets[ex_coord_offset_index]
                                updated_exon_starts.append(updated_exon_coord)
                            for coord in exon_ends:
                                ex_coord_offset_index = bisect.bisect_right(current_chrom_variant_coords, coord) - 1
                                updated_exon_coord = coord
                                if ex_coord_offset_index >= 0:
                                    updated_exon_coord += current_chrom_variant_offsets[ex_coord_offset_index]
                                updated_exon_ends.append(updated_exon_coord)
                    #No new variants between the start and stop coordinates, so
                    #apply the same offset to all coordinates in the current
                    #feature.
                    elif tx_start_offset_index == tx_end_offset_index:
                        offset = current_chrom_variant_offsets[tx_start_offset_index]
                        updated_tx_start = tx_start + offset
                        updated_tx_end = tx_end + offset
                        updated_exon_starts = [coord+offset for coord in exon_starts]
                        updated_exon_ends = [coord+offset for coord in exon_ends]
                    else:
                        updated_tx_start = tx_start + current_chrom_variant_offsets[tx_start_offset_index]
                        updated_tx_end = tx_end + current_chrom_variant_offsets[tx_end_offset_index]

                        #Update lists of exon starts/ends with correct offsets
                        updated_exon_starts = []
                        updated_exon_ends = []
                        for coord in exon_starts:
                            ex_coord_offset_index = bisect.bisect_right(current_chrom_variant_coords, coord) - 1
                            updated_exon_coord = coord + current_chrom_variant_offsets[ex_coord_offset_index]
                            updated_exon_starts.append(updated_exon_coord)
                        for coord in exon_ends:
                            ex_coord_offset_index = bisect.bisect_right(current_chrom_variant_coords, coord) - 1
                            updated_exon_coord = coord + current_chrom_variant_offsets[ex_coord_offset_index]
                            updated_exon_ends.append(updated_exon_coord)

                    #Format updated annotation data and output
                    updated_annot_file.write(
                        ExpressionUtils.annot_output_format.format(
                            chrom=line_data[0],
                            strand=line_data[1],
                            txStart=updated_tx_start,
                            txEnd=updated_tx_end,
                            exonCount=line_data[4],
                            exonStarts=','.join([str(x) for x in updated_exon_starts]),
                            exonEnds=','.join([str(x) for x in updated_exon_ends]),
                            transcriptID=line_data[7],
                            geneID=line_data[8],
                            geneSymbol=line_data[9],
                            biotype=line_data[10]
                        )
                    )

                #No variants in the current chromosome, so no need to update
                #feature coordinates.
                else:
                    updated_annot_file.write(f"{annot_feature}\n")
    @staticmethod
    def _get_chr_ploidy_from_file(chr_ploidy_filename):
        chr_ploidy = dict()
        with open(chr_ploidy_filename) as chr_ploidy_file:
            chr_ploidy_file.readline() # Header line
            for line in chr_ploidy_file:
                chrom, male, female = line.strip().split("\t")
                chr_ploidy[chrom] = (int(male), int(female))
        return chr_ploidy

    @staticmethod
    def _get_offsets_from_variant_file(genome_indel_filename):
        """Read indel file, calculate rolling offset at each variant position
        and return results as a dictionary of ordered dictionaries, indexed by
        chromoeomse name.

        This method requires the genome_indel_filename attribute is set and
        contains a valid filename.

        Parameters
        ----------
        genome_indel_filename : string
            Full path to indel file generated by GenomeFilesPreparation. This
            file must be sorted by chromosome (any sorting order) and by indel
            coordinate (numerical order).

        Returns
        -------
        OrderedDict nested in defaultdict
            Ordered collection of rolling offsets for each chromosome.
            For outer defaultdict:
                Key = chromosome/contig name from indel file
                Value = OrderedDict (see below)
            For inner OrderedDict:
                Key = chromosomal coordinate of variant position
                Value = rolling offest at variant position
            So variant_offsets["chr1"][12345] stores the rolling offset at
            position 12345 on chromosome 1.

        """

        with open(genome_indel_filename, 'r') as genome_indel_file:

            """
            By using the defaultdict object, I can specify the default value
            used every time I create a new key. This way, I don't need to
            include code to check and instantiate keys with empty OrderedDict
            objects. It's all handed by the defaultdict
            """
            variant_offsets = collections.defaultdict(collections.OrderedDict)
            rolling_offset = 0
            curr_chrom = ""

            for line in genome_indel_file:
                line_data = line.split('\t')
                indel_chrom, indel_position = line_data[0].split(':')
                indel_position = int(indel_position)
                indel_type = line_data[1]
                indel_offset = int(line_data[2])

                #Reset rolling offset for new chromosome
                if curr_chrom != indel_chrom:
                    rolling_offset = 0
                    curr_chrom = indel_chrom

                #If variant is a deletion, make offset negative so it subtracts
                #from the rolling offset.
                if indel_type == 'D':
                    indel_offset *= -1

                rolling_offset += indel_offset
                variant_offsets[indel_chrom][indel_position] = rolling_offset

            return variant_offsets

    @staticmethod
    def main():
        from beers.sample import Sample
        """Entry point into script when called directly.

        Parses arguments, gathers input and output filenames, and calls scripts
        that perform the actual operation.

        Returns
        -------
        type
            Description of returned object.

        """
        parser = argparse.ArgumentParser(description='Update annotation file with'
                                                     ' coordinates for variant genome')
        parser.add_argument('-i', '--input_annot_file_path')
        parser.add_argument('-s', '--sample_id', type=int, help='sample name in vcf when prepended with sample')
        parser.add_argument('-g', '--genome_indel_suffix', help="Suffix that distinguishes genome names")
        parser.add_argument('-l', '--log_directory_path', help="Path to log directory.")
        parser.add_argument('-d', '--data_directory_path', help='Path to data directory')

        args = parser.parse_args()

        test_sample = Sample(args.sample_id, "debug sample", None, None, None)

        # Remove old update annotation data and log files if present
        sample_data_folder = os.path.join(args.data_directory_path, f'sample{test_sample.sample_id}')
        for item in os.listdir(sample_data_folder):
            if item.startswith("updated_annotation"):
                os.remove(os.path.join(sample_data_folder, item))
        sample_log_folder = os.path.join(args.log_directory_path, f'sample{test_sample.sample_id}')
        for item in os.listdir(sample_log_folder):
            if item.startswith("UpdateAnnotationForGenomeStep"):
                os.remove(os.path.join(sample_log_folder, item))

        updated_annotation = UpdateAnnotationForGenomeStep(args.log_directory_path, args.data_directory_path)
        start = timer()
        updated_annotation.execute(test_sample, args.genome_indel_suffix, args.input_annot_file_path)
        end = timer()
        print(f"Updated annotation: {end - start}")

if __name__ == '__main__':
    sys.exit(UpdateAnnotationForGenomeStep.main())

'''
python update_annotation_for_genome.py \
-i '../../resources/index_files/GRCh38/Homo_sapiens.GRCh38.92.annotation.sorted_to_match_fasta.txt' \
-s 1 \
-g 1 \
-d ../../data/pipeline_results_run99/expression_pipeline/data \
-l ../../data/pipeline_results_run99/expression_pipeline/logs
'''
